<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Custom Oracles · ApproximateVanishingIdeals.jl</title><meta name="title" content="Custom Oracles · ApproximateVanishingIdeals.jl"/><meta property="og:title" content="Custom Oracles · ApproximateVanishingIdeals.jl"/><meta property="twitter:title" content="Custom Oracles · ApproximateVanishingIdeals.jl"/><meta name="description" content="Documentation for ApproximateVanishingIdeals.jl."/><meta property="og:description" content="Documentation for ApproximateVanishingIdeals.jl."/><meta property="twitter:description" content="Documentation for ApproximateVanishingIdeals.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">ApproximateVanishingIdeals.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../basics/">How does it work?</a></li><li><span class="tocitem">Obtaining a transformation</span><ul><li><a class="tocitem" href="../how_to_run/">Obtaining a transformation</a></li><li><a class="tocitem" href="../docs_oavi_transformation/">Transforming data using <span>$\; \texttt{OAVI}$</span></a></li><li class="is-active"><a class="tocitem" href>Custom Oracles</a><ul class="internal"><li><a class="tocitem" href="#Preparing-data"><span>Preparing data</span></a></li><li><a class="tocitem" href="#Creating-the-objective-function"><span>Creating the objective function</span></a></li><li><a class="tocitem" href="#Defining-the-feasible-region"><span>Defining the feasible region</span></a></li><li><a class="tocitem" href="#Calling-the-Oracle"><span>Calling the Oracle</span></a></li><li><a class="tocitem" href="#Putting-it-all-together"><span>Putting it all together</span></a></li></ul></li><li><a class="tocitem" href="../docs_vca_transformation/">Transforming data using <span>$\; \texttt{VCA}$</span></a></li></ul></li><li><a class="tocitem" href="../print_polynomials/">Printing polynomials</a></li><li><span class="tocitem">API Reference</span><ul><li><a class="tocitem" href="../reference/0_reference/">API Reference</a></li><li><a class="tocitem" href="../reference/1_algorithms/">Algorithms</a></li><li><a class="tocitem" href="../reference/2_oracles/">Oracles</a></li><li><a class="tocitem" href="../reference/3_border/">Border construction</a></li><li><a class="tocitem" href="../reference/4_terms_and_polys/">Terms and polynomials</a></li><li><a class="tocitem" href="../reference/5_auxiliary_funcs/">Auxiliary functions</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Obtaining a transformation</a></li><li class="is-active"><a href>Custom Oracles</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Custom Oracles</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/ZIB-IOL/ApproximateVanishingIdeals.jl.git" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/ZIB-IOL/ApproximateVanishingIdeals.jl/blob/main/docs/src/docs_custom_oracle.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Custom-Oracles"><a class="docs-heading-anchor" href="#Custom-Oracles">Custom Oracles</a><a id="Custom-Oracles-1"></a><a class="docs-heading-anchor-permalink" href="#Custom-Oracles" title="Permalink"></a></h1><p>In this section we will present an example of how to construct your own oracle to run in <span>$\texttt{OAVI}$</span>. We will be showing this for the objective function <span>$\frac{1}{m}\|Ax + b\|_2^2$</span> and a Frank-Wolfe oracle. It is easily extendable to other setups.</p><h2 id="Preparing-data"><a class="docs-heading-anchor" href="#Preparing-data">Preparing data</a><a id="Preparing-data-1"></a><a class="docs-heading-anchor-permalink" href="#Preparing-data" title="Permalink"></a></h2><p>Since custom oracles may vary in the data needed for the computations, we only require a custom oracle to need <code>data</code> and <code>labels</code> to construct everything, i.e. the data matrix <span>$A$</span>, consisting of the non-leading term evaluations and the label vector <span>$b$</span>, which holds the evaluations of the current leading term candidate. The first step is to prepare the data you need for your objective function. For our example, we extend our function to better see which combinations of the inputs we need.</p><p class="math-container">\[\frac{1}{m}\|Ax+b\|_2^2 = \frac{1}{m} \langle Ax+b, Ax+b\rangle = \frac{1}{m} (\langle Ax, Ax\rangle + 2\langle Ax, b\rangle + \langle b, b\rangle).\]</p><p>Writing this in the form of matrix-vector multiplication, we get</p><p class="math-container">\[\frac{1}{m} (\langle Ax, Ax\rangle + 2\langle Ax, b\rangle + \langle b, b\rangle) = \frac{1}{m}(x^\top A^\top A x + 2x^\top A^\top b + b^\top b).\]</p><p>Now we can easily see which combinations of <span>$A$</span> and <span>$b$</span> we need. Let&#39;s write a function that computes all the necessary parts. Inlcuding a <span>$\frac{2}{m}$</span> factor instead of <span>$\frac{1}{m}$</span> is just personal preference. We simply divide by <span>$2$</span> later.</p><pre><code class="language-julia hljs">using ApproximateVanishingIdeals
using FrankWolfe
using LinearAlgebra
using Random

function prepare_data(A, b)
    m, _ = size(A)
    # A.T A
    A_squared = 2/m * (A&#39; * A)

    # A.T b
    A_b = 2/m * (A&#39; * b)

    # b.T b
    b_squared = 2/m * (b&#39; * b)

    return A_squared, A_b, b_squared
end</code></pre><h2 id="Creating-the-objective-function"><a class="docs-heading-anchor" href="#Creating-the-objective-function">Creating the objective function</a><a id="Creating-the-objective-function-1"></a><a class="docs-heading-anchor-permalink" href="#Creating-the-objective-function" title="Permalink"></a></h2><p>The next step is to create the objective function (and in our case its gradient). For this we use the previously defined function to prepare the data and create the objective.</p><pre><code class="language-julia hljs">function objective(data, labels)
    # prepare data for objective
    A_squared, A_b, b_squared = prepare_data(data, labels)

    # define objective
    function evaluate_objective(x)
        return (1 / 2) * (x&#39; * A_squared * x) + (x&#39; * A_b) + (1 / 2) * b_squared
    end

    # define gradient
    function evaluate_gradient!(storage, x)
        # &#39;storage&#39; is specific to structure in &#39;FrankWolfe.jl&#39;
        return storage .= A_squared * x + A_b
    end

    return evaluate_objective, evaluate_gradient!
end</code></pre><h2 id="Defining-the-feasible-region"><a class="docs-heading-anchor" href="#Defining-the-feasible-region">Defining the feasible region</a><a id="Defining-the-feasible-region-1"></a><a class="docs-heading-anchor-permalink" href="#Defining-the-feasible-region" title="Permalink"></a></h2><p>Since we are dealing with a constrained optimization problem, defining a feasible region is necessary. We will use FrankWolfe.jl&#39;s built-in feasible regions, however one may construct their own feasible region through other means, so for the sake of this presentation we will once again define a function. This function will define the <span>$\ell_p$</span>-ball with a given radius.</p><pre><code class="language-julia hljs">function feasible_region(p, radius)
    return FrankWolfe.LpNormLMO{p}(radius)
end</code></pre><p>Closely tied with the feasible region is the choice of a starting point for the oracle. For the <code>LpNormLMO</code> we can use <code>compute_extreme_point</code> to obtain a starting vertex of our feasible region by calling <code>region = feasible_region(1, 1000)</code> and after that <code>x0 = compute_extreme_point(region, zeros(Float64, size(data, 2)))</code></p><h2 id="Calling-the-Oracle"><a class="docs-heading-anchor" href="#Calling-the-Oracle">Calling the Oracle</a><a id="Calling-the-Oracle-1"></a><a class="docs-heading-anchor-permalink" href="#Calling-the-Oracle" title="Permalink"></a></h2><p>The final step for our custom oracle is calling the oracle with all the things we prepared. <span>$\texttt{OAVI}$</span> requires degree-lexicographical term ordering and assumes a leading term coefficient of <span>$1$</span>. Be sure to return not only the coefficient vector <span>$x^*$</span> for the non-leading terms, but extend the coefficient vector by the leading term coefficient <span>$1$</span>.</p><p>With the coefficient vector obtained, we compute the loss and return both <code>coefficient_vector</code> and <code>loss</code>. As an example we take the <code>blended_conditional_gradient</code> algorithm as an oracle.</p><pre><code class="language-julia hljs">function custom_oracle(data, labels; epsilon=1.0e-7, max_iteration=10000)
    # get necessary data
    f, grad! = objective(data, labels)
    region = feasible_region(1, 1000.)
    x0 = compute_extreme_point(region, zeros(Float64, size(data, 2)))

    # obtain coefficient vector
    coefficient_vector, _ = blended_conditional_gradient(
                                                        f,
                                                        grad!,
                                                        region,
                                                        x0;
                                                        epsilon=epsilon,
                                                        max_iteration=max_iteration
                                                        )

    # compute loss
    loss = f(coefficient_vector)

    # extend coefficient vector with leading term coefficient 1
    coefficient_vector = vcat(coefficient_vector, [1])

    return coefficient_vector, loss
end</code></pre><h2 id="Putting-it-all-together"><a class="docs-heading-anchor" href="#Putting-it-all-together">Putting it all together</a><a id="Putting-it-all-together-1"></a><a class="docs-heading-anchor-permalink" href="#Putting-it-all-together" title="Permalink"></a></h2><p>Now that you know what your custom oracle is expected to return and how one can go about defining such a constructor, it remains to give it to <span>$\texttt{OAVI}$</span> to use.</p><pre><code class="language-julia hljs"># some data
X = rand(10000, 10)

# transformation obtained through OAVI by using your custom oracle
X_transformed, sets = fit_oavi(X; oracle=custom_oracle)</code></pre><p>You can also pass further kwargs used by your oracle and we will pass them through to your oracle call. This is done by the <code>oracle_kwargs</code> argument. Let&#39;s say we want to pass the keyword arguments <code>epsilon=1.0e-5</code> and <code>max_iteration=5000</code> along to our custom oracle.</p><pre><code class="language-julia hljs">kwargs = [(:epsilon, 1.0e-5), (:max_iteration, 5000)]

X_transformed, sets = fit_oavi(X; oracle=custom_oracle, oracle_kwargs=kwargs)</code></pre><p>The above code will call <code>custom_oracle</code> with the keyword arguments <code>epsilon</code> and <code>max_iteration</code> exchanged for <code>1.0e-5</code> and <code>5000</code>, respectively, that is, <code>custom_oracle(data, labels; epsilon=1.0e-5, max_iteration=5000)</code> and ultimately when calling the algorithm in our example <code>blended_conditional_gradient(f, grad!, region, x0; epsilon=1.0e-5, max_iteration=5000)</code>.</p><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../docs_oavi_transformation/">« Transforming data using <span>$\; \texttt{OAVI}$</span></a><a class="docs-footer-nextpage" href="../docs_vca_transformation/">Transforming data using <span>$\; \texttt{VCA}$</span> »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.2.1 on <span class="colophon-date" title="Wednesday 21 February 2024 14:06">Wednesday 21 February 2024</span>. Using Julia version 1.6.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
