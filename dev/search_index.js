var documenterSearchIndex = {"docs":
[{"location":"how_to_run/#Obtaining-a-transformation","page":"Obtaining a transformation","title":"Obtaining a transformation","text":"","category":"section"},{"location":"how_to_run/","page":"Obtaining a transformation","title":"Obtaining a transformation","text":"With basics about the method out of the way, let's take a look at how we can obtain a feature transformation using the provided algorithms.","category":"page"},{"location":"how_to_run/#\\texttt{OAVI}-transformation","page":"Obtaining a transformation","title":"textttOAVI transformation","text":"","category":"section"},{"location":"how_to_run/","page":"Obtaining a transformation","title":"Obtaining a transformation","text":"To obtain a simple transformation, one can proceed to follow the steps presented earlier. As explained, however, we recommend tweaking a couple of parameters to achieve better results. The two main arguments this applies to are psi, the vanishing parameter, under the keyword psi and varepsilon, the accuracy to which the oracle solves the problem, under the keyword epsilon. These are by default psi=0.1 and epsilon=1.0e-7. Let's say we want to use psi=0.005 and epsilon=1.0e-5, then the code should look as follows:","category":"page"},{"location":"how_to_run/","page":"Obtaining a transformation","title":"Obtaining a transformation","text":"using AVI\n\nX = your_data_set\ntransformed_data, sets = fit_oavi(X; psi=0.005, epsilon=1.0e-5)","category":"page"},{"location":"how_to_run/","page":"Obtaining a transformation","title":"Obtaining a transformation","text":"While epsilon should be adjusted according to the solver used, or personal preference for that matter, the psi keyword has a direct influence on the degree of polynomials constructed. It was shown in Wirth, Kera and Pokutta that the algorithm terminates after having constructed polynomials of degree","category":"page"},{"location":"how_to_run/","page":"Obtaining a transformation","title":"Obtaining a transformation","text":"D = lceil -log(psi)log(4) rceil","category":"page"},{"location":"how_to_run/","page":"Obtaining a transformation","title":"Obtaining a transformation","text":"if tau ge (32)^D. The tau parameter by default takes the value of this lower bound, but it is possible to adjust it if one wants to. ","category":"page"},{"location":"how_to_run/#Different-built-in-Oracles","page":"Obtaining a transformation","title":"Different built-in Oracles","text":"","category":"section"},{"location":"how_to_run/","page":"Obtaining a transformation","title":"Obtaining a transformation","text":"We previously alluded to three different oracles being available in the code, frank_wolfe, blended_conditional_gradient and blended_pairwise_conditional_gradient. The default option is frank_wolfe, which has the keyword arugment oracle=\"CG\". The others can be accessed as follows:","category":"page"},{"location":"how_to_run/","page":"Obtaining a transformation","title":"Obtaining a transformation","text":"# Standard Frank-Wolfe. Both these formulations are the same.\nfit_oavi(X)\nfit_oavi(X; oracle=\"CG\")   \n\n# Blended conditional gradients\nfit_oavi(X; oracle=\"BCG\")\n\n# Blended pairwise conditional gradients\nfit_oavi(X; oracle=\"BPCG\")","category":"page"},{"location":"how_to_run/#Custom-Oracles","page":"Obtaining a transformation","title":"Custom Oracles","text":"","category":"section"},{"location":"how_to_run/","page":"Obtaining a transformation","title":"Obtaining a transformation","text":"It is also possible to provide your own oracle for solving the convex optimization problem. The code expects your constructor to work with the two variable arguments data and labels, which are the data matrix A and the label vector b found in Ax + b^2. Further, you can add your keyword arguments under oracle_kwargs. In the Examples section, we will show you how to construct a custom oracle by showing an example with an oracle from FrankWolfe.jl.","category":"page"},{"location":"how_to_run/#\\texttt{ABM}","page":"Obtaining a transformation","title":"textttABM","text":"","category":"section"},{"location":"how_to_run/","page":"Obtaining a transformation","title":"Obtaining a transformation","text":"Through the keyword oracle we can also call the textttABM algorithm instead. This can be accessed as follows:","category":"page"},{"location":"how_to_run/","page":"Obtaining a transformation","title":"Obtaining a transformation","text":"# Approximate Buchberger-Möller\nfit_oavi(X; oracle=\"ABM\")","category":"page"},{"location":"how_to_run/#\\texttt{VCA}-transformation","page":"Obtaining a transformation","title":"textttVCA transformation","text":"","category":"section"},{"location":"how_to_run/","page":"Obtaining a transformation","title":"Obtaining a transformation","text":"Apart from textttOAVI with its multiple different possibilities of running, we also provide an implementation of the textttVCA algorithm introduced in Livni et al. (2013). The algorithm is implemented in fit_vca and a feature transformation based on textttVCA can be obtained by calling","category":"page"},{"location":"how_to_run/","page":"Obtaining a transformation","title":"Obtaining a transformation","text":"using AVI\n\nX = your_data_set\nX_transformed_vca, sets_vca = fit_vca(X)","category":"page"},{"location":"how_to_run/","page":"Obtaining a transformation","title":"Obtaining a transformation","text":"Similar to textttOAVI, the vanishing parameter psi is adjustable for textttVCA through the keyword psi. To the best of our knowledge, there is currently no similar guarantee on the degree of constructed polynomials for textttVCA as there is for textttOAVI, but adjusting psi and comparing results is nonetheless recommended.","category":"page"},{"location":"basics/#How-does-it-work?","page":"How does it work?","title":"How does it work?","text":"","category":"section"},{"location":"basics/","page":"How does it work?","title":"How does it work?","text":"AVI.jl contains routines to construct approximately vanishing polynomials from the data processed previously. Through the iterations, the data used for construction is expanded with the evaluation of non-leading terms over the data points textttX. ","category":"page"},{"location":"basics/#Oracle-Approximate-Vanishing-Ideal-algorithm-(\\texttt{OAVI})","page":"How does it work?","title":"Oracle Approximate Vanishing Ideal algorithm (textttOAVI)","text":"","category":"section"},{"location":"basics/","page":"How does it work?","title":"How does it work?","text":"The Oracle Approximate Vanishing Ideal (textttOAVI) algorithm solves the convex optimization problem ","category":"page"},{"location":"basics/","page":"How does it work?","title":"How does it work?","text":"x^* in argmin_x_1 le tau Ax + b_2^2","category":"page"},{"location":"basics/","page":"How does it work?","title":"How does it work?","text":"where A is the matrix of non-leading terms evaluated over the data textttX and b is the current leading term candidate. Through the use of an oracle, the algorithm finds the coefficient vecotr x^* which minimizes the above problem. ","category":"page"},{"location":"basics/","page":"How does it work?","title":"How does it work?","text":"The algorithm is implemented in the fit_oavi function. See E. Wirth and S. Pokutta (2022) for more details about the method.","category":"page"},{"location":"basics/#Frank-Wolfe-algorithms-as-Oracle","page":"How does it work?","title":"Frank-Wolfe algorithms as Oracle","text":"","category":"section"},{"location":"basics/","page":"How does it work?","title":"How does it work?","text":"One such class of methods are 'Frank-Wolfe' algorithms. The FrankWolfe.jl package provides implementations of many different version of the Frank-Wolfe algorithm, as well as implementations of Linear Minimization Oracles that find an optimal vertex of the feasible set along a given direction.","category":"page"},{"location":"basics/","page":"How does it work?","title":"How does it work?","text":"You can choose from the standard frank_wolfe, the blended_conditional_gradient and the blended_pairwise_conditional_gradient Frank-Wolfe algorithms by using the keyword argument oracle = \"CG\", oracle = \"BCG\" and oracle = \"BPCG\", respectively. For all of those we create the L1-ball of radius tau as well as the squared euclidean norm Ax+b_2^2 as the objective function, as stated above.","category":"page"},{"location":"basics/#Approximate-Buchberger-Möller-(\\texttt{ABM})","page":"How does it work?","title":"Approximate Buchberger-Möller (textttABM)","text":"","category":"section"},{"location":"basics/","page":"How does it work?","title":"How does it work?","text":"The Approximate Buchberger-Möller (textttABM) algorithm is another related algorithm which shares the degree-lexicographical term ordering as well as processing terms of a given degree d one by one instead of all at once. Due to these similarities we elected to implement textttABM inside of fit_oavi. The algorithm can be run by providing the keyword argument oracle = \"ABM\". See J. Limbeck (2013), Chapter 4 for more details about the method.","category":"page"},{"location":"basics/#Vanishing-Component-Analysis-(\\texttt{VCA})","page":"How does it work?","title":"Vanishing Component Analysis (textttVCA)","text":"","category":"section"},{"location":"basics/","page":"How does it work?","title":"How does it work?","text":"The Vanishing Component Analysis (textttVCA) algorithm is the final algorithm implemented in this repository. It is once again a method to obtain a polynomial feature transformation with small but significant differences compared to textttOAVI. The main differences are textttVCA not relying on degree-lexicographic ordering of terms when processing terms and using SVD to obtain coefficient vectors in contrast to the use of an oracle in textttOAVI. See Livni et al. (2013) for additional information.","category":"page"},{"location":"reference/2_oracles/#Oracles","page":"Oracles","title":"Oracles","text":"","category":"section"},{"location":"reference/2_oracles/","page":"Oracles","title":"Oracles","text":"This section contains information about the different oracles for textttOAVI.","category":"page"},{"location":"reference/2_oracles/#Frank-Wolfe","page":"Oracles","title":"Frank-Wolfe","text":"","category":"section"},{"location":"reference/2_oracles/","page":"Oracles","title":"Oracles","text":"AVI.conditional_gradients","category":"page"},{"location":"reference/2_oracles/#AVI.conditional_gradients","page":"Oracles","title":"AVI.conditional_gradients","text":"Returns coefficient_vector and loss found through CG-based algorithm fit to 'data'.\n\nArguments\n\n'oracle_type::String': type of CG-based algorithm (choice from 'CG', 'BCG', 'BPCG')\n'data::Union{Matrix{Float64}, Matrix{Int64}}': evaluations of O_terms \n'labels::Union{Vector{Float64}, Vector{Int64}}': current border term evaluated\n'lambda::Union{Float64, Int64}': regularization parameter\n'data_squared::Union{Matrix{Float64}, Matrix{Int64}}': data' * data \n'data_labels::Vector{Float64}': data' * labels\n'labels_squared::Float64': labels' * labels\n'datasquaredinverse::Union{Matrix{Float64}, Matrix{Int64}, Nothing}': inverse of data_squared for IHB, optional (default is nothing)\n'psi::Float64': vanishing parameter, optional (default is 0.1)\n'epsilon::Float64': solver accuracy, optional (default is 0.001)\n'tau::Float64': bound on coefficient_vector norm, optional (default is 1000.)\n'inversehessianboost::String': whether or not to use IHB (choice from 'false', 'weak', 'full'), optional (default is 'false')\n\nReturns\n\n'coefficientvector::Vector{Float64}': coefficientvector minimizing L2Loss over L1Ball\n'loss::Float64': loss w.r.t. 'coefficient_vector'\n\n\n\n\n\n","category":"function"},{"location":"reference/2_oracles/#Objective-function","page":"Oracles","title":"Objective function","text":"","category":"section"},{"location":"reference/2_oracles/","page":"Oracles","title":"Oracles","text":"Tied to the Frank-Wolfe oracles is the construction of the objective function, the L2-loss function.","category":"page"},{"location":"reference/2_oracles/","page":"Oracles","title":"Oracles","text":"AVI.L2Loss","category":"page"},{"location":"reference/2_oracles/#AVI.L2Loss","page":"Oracles","title":"AVI.L2Loss","text":"Creates and returns objective function, gradient and solution (through inversion) w.r.t. L2 loss.\n\nArguments\n\n'data::Union{Matrix{Float64}, Matrix{Int64}}': evaluations of O_terms \n'labels::Union{Vector{Float64}, Vector{Int64}}': current border term evaluated\n'lambda::Union{Float64, Int64}': regularization parameter\n'data_squared::Union{Matrix{Float64}, Matrix{Int64}}': data' * data \n'data_labels::Vector{Float64}': data' * labels\n'labels_squared::Float64': labels' * labels\n'datasquaredinverse::Union{Matrix{Float64}, Matrix{Int64}, Nothing}': inverse of data_squared for IHB, optional (default is nothing)\n\nReturns\n\n'solution::Vector{Float64}': solution to (unconstrained) minimization problem\n'evaluate_function<:Function': objective function\n'evaluate_gradient!<:Function': gradient of objective function, adjusted to FrankWolfe requirements\n\n\n\n\n\n","category":"function"},{"location":"reference/2_oracles/#Approximate-Buchberger-Möller-(ABM)","page":"Oracles","title":"Approximate Buchberger-Möller (ABM)","text":"","category":"section"},{"location":"reference/2_oracles/","page":"Oracles","title":"Oracles","text":"AVI.abm","category":"page"},{"location":"reference/2_oracles/#AVI.abm","page":"Oracles","title":"AVI.abm","text":"Runs ABM algorithm to find coefficient vector and computes loss.\n\nArguments\n\n'oracle_type::String': string denoting which oracle to construct\n'data::Union{Matrix{Float64}, Matrix{Int64}}': data (O_evaluations)\n'labels::Union{Vector{Float64}, Vector{Int64}}': labels (term_evaluated)\n'lambda::Union{Float64, Int64}': regularization parameter (if applicable)\n'data_squared::Union{Matrix{Float64}, Matrix{Int64}}': squared data \n'data_labels::Vector{Float64}': data' * labels \n'labels_squared::Float64': labels' * labels\n'datasquaredinverse::Union{Matrix{Float64}, Matrix{Int64}, Nothing}': inverse of data_squared (default is nothing)\n\nReturns\n\n'coefficient_vector::Vector{Float64}': coefficient vector minimizing ABM optimization problem\n'loss::Float64': loss w.r.t. 'coefficient_vector' \n\n\n\n\n\n","category":"function"},{"location":"reference/2_oracles/#Index","page":"Oracles","title":"Index","text":"","category":"section"},{"location":"reference/2_oracles/","page":"Oracles","title":"Oracles","text":"Pages=[\"2_oracles.md\"]","category":"page"},{"location":"reference/3_border/#Border-construction","page":"Border construction","title":"Border construction","text":"","category":"section"},{"location":"reference/3_border/","page":"Border construction","title":"Border construction","text":"This section contains information about the construction of borders for textttOAVI.","category":"page"},{"location":"reference/3_border/#Initial-construction","page":"Border construction","title":"Initial construction","text":"","category":"section"},{"location":"reference/3_border/","page":"Border construction","title":"Border construction","text":"The first time constructing the border we need to handle non-unique terms, purge them and then only continue with the relevant terms and corresponding evaluations.","category":"page"},{"location":"reference/3_border/","page":"Border construction","title":"Border construction","text":"AVI.construct_border","category":"page"},{"location":"reference/3_border/#AVI.construct_border","page":"Border construction","title":"AVI.construct_border","text":"constructs the border of 'terms'\n\nArguments\n\n'terms::Matrix{Int64}': Matrix with monomial terms as columns\n'terms_evaluated::Matrix{Float64}': Matrix with evaluations of 'terms' over X\n'X_train::Vector{Vector{Float64}}': data\n'degree1terms::Matrix{Int64}': Matrix with degree 1 monomials as columns\n'degree1termsevaluated::Matrix{Float64}': evaluations of 'degree1_terms' over X\n'purging_terms::Matrix{Int64}': purge terms in 'terms' divisible by any of these \n\nReturns\n\n'bordertermsraw::Matrix{Int64}': non-purged border constructed from 'terms'\n'borderevaluationsraw::Matrix{Float64}': non-purged evaluations of border terms over X\n'nonpurgingindices::Vector{Int64}': array of non-purging indices\n'raw_permutation::Vector{Int64}': array with deg-lex ordering permutation\n\n\n\n\n\n","category":"function"},{"location":"reference/3_border/","page":"Border construction","title":"Border construction","text":"AVI.purge","category":"page"},{"location":"reference/3_border/#AVI.purge","page":"Border construction","title":"AVI.purge","text":"purges each term in 'terms' that is divisible by at least one term 'purging_terms'\n\nArguments\n\n'terms::Matrix{Int64}': Matrix with monomial terms as columns\n'terms_evaluated::Matrix{Float64}': evaluations of 'terms' over data\n'purging_terms::Matrix{Int64}': Matrix with purging terms as columns\n\nReturns\n\n'terms[:, inidces]::Matrix{Int64}': purged version of terms\n'terms_evaluated[:, indices]::Matrix{Float64}': purged evaluations\n'indices::Vector{Int64}': array with non-purging indices\n\n\n\n\n\n","category":"function"},{"location":"reference/3_border/#Reconstruction-of-the-border","page":"Border construction","title":"Reconstruction of the border","text":"","category":"section"},{"location":"reference/3_border/","page":"Border construction","title":"Border construction","text":"When applying the transformation mathcalG found by OAVI, we need to reconstruct the border. This can be sped up by using the computations done in construct_border to avoid unnecessary recomputations of known values. ","category":"page"},{"location":"reference/3_border/","page":"Border construction","title":"Border construction","text":"AVI.reconstruct_border","category":"page"},{"location":"reference/3_border/#AVI.reconstruct_border","page":"Border construction","title":"AVI.reconstruct_border","text":"reconstructs border for O_test\n\n\n\n\n\n","category":"function"},{"location":"reference/3_border/#Index","page":"Border construction","title":"Index","text":"","category":"section"},{"location":"reference/3_border/","page":"Border construction","title":"Border construction","text":"Pages=[\"3_border.md\"]","category":"page"},{"location":"docs_oavi_transformation/#Transforming-data-using-\\texttt{OAVI}","page":"Transforming data using textttOAVI","title":"Transforming data using textttOAVI","text":"","category":"section"},{"location":"docs_oavi_transformation/","page":"Transforming data using textttOAVI","title":"Transforming data using textttOAVI","text":"Finding the right transformation for your data with textttOAVI is heavily tied to the vanishing parameter psi. As previously stated, textttOAVI terminates after having constructed polynomials of degree","category":"page"},{"location":"docs_oavi_transformation/","page":"Transforming data using textttOAVI","title":"Transforming data using textttOAVI","text":"D = lceil -log(psi)log(4) rceil","category":"page"},{"location":"docs_oavi_transformation/","page":"Transforming data using textttOAVI","title":"Transforming data using textttOAVI","text":"so tweaking the psi parameter is advised when searching for the best transformation. Below you can find a figure roughly indicating the influence of psi on the degree D. If you have some prior knowledge about the underlying structure of your data and can somewhat restrict the polynomial degree you need, limiting the range of psi's one tests can help avoid unnecessarily long runtime.","category":"page"},{"location":"docs_oavi_transformation/","page":"Transforming data using textttOAVI","title":"Transforming data using textttOAVI","text":"(Image: Degree of terms)","category":"page"},{"location":"docs_oavi_transformation/#Choosing-the-right-transformation","page":"Transforming data using textttOAVI","title":"Choosing the right transformation","text":"","category":"section"},{"location":"docs_oavi_transformation/","page":"Transforming data using textttOAVI","title":"Transforming data using textttOAVI","text":"Let's read in some data first. To keep it general we will create some small random .csv file but feel free to read in your favorite data set.","category":"page"},{"location":"docs_oavi_transformation/","page":"Transforming data using textttOAVI","title":"Transforming data using textttOAVI","text":"using AVI\nusing DataFrames\nusing CSV\nusing Random\n\n# create data\nX = rand(100, 3)\n\n# put it into a DataFrame\ndf = DataFrame(X, :auto)\n\n# write it to 'example.csv' in 'examples' folder\nCSV.write(\"examples/example.csv\", df);\n\n# read the data\nread_df = CSV.read(\"examples/example.csv\", DataFrame, types=Float64)\n\n# convert DataFrame to Matrix\ndata = Matrix(read_df)","category":"page"},{"location":"docs_oavi_transformation/","page":"Transforming data using textttOAVI","title":"Transforming data using textttOAVI","text":"Be sure that you read in your data with Float64 as the type for your data as fit_oavi assumes the entries in the data matrix to be of type Float64.","category":"page"},{"location":"docs_oavi_transformation/","page":"Transforming data using textttOAVI","title":"Transforming data using textttOAVI","text":"Now we can start finding which psi works best for us. Choose some values for psi you want to test, for example psis = [0.01, 0.005, 0.001, 0.0005]. Then you loop through each psi, check the e.g. classification error using your favorite classifier and choose the one that performs best.","category":"page"},{"location":"docs_oavi_transformation/","page":"Transforming data using textttOAVI","title":"Transforming data using textttOAVI","text":"# split train and test data\nX_train, X_test = data[1:90, :], data[91:end, :]\n\n# define psis\npsis = [0.01, 0.005, 0.001, 0.0005]\n\n# init best transform and best sets\nbest_transform, best_sets = nothing, nothing\n\n# init error\nerror = Inf64\n\n# loop psis\nfor psi in psis\n    # transformation with current psi\n    X_train_transformed, sets_train = fit_oavi(X_train; psi=psi)\n\n    \"\"\"\n    We do not provide a built-in classifier so feel free to use your favorite one here.\n    if X_train_transformed !== nothing\n        new_error = classifier(X_train_transformed, class_labels)\n        if new_error < error\n            error = new_error\n            best_transform, best_sets = X_train_transformed, sets_train\n        end\n    end\n    \"\"\"\nend","category":"page"},{"location":"docs_oavi_transformation/#Applying-the-transformation","page":"Transforming data using textttOAVI","title":"Applying the transformation","text":"","category":"section"},{"location":"docs_oavi_transformation/","page":"Transforming data using textttOAVI","title":"Transforming data using textttOAVI","text":"Having found the transformation that works best on your training set, you would naturally want to apply this transformation to the data you want to classify. Since we already computed the borders and related values when constructing the transformation, we want to avoid unnecessary and expensive recomputations on testing data. For this we provide the function apply_G_transformation which takes as arguments sets and X_test and transforms X_test according to the transformation stored in sets. As to not get an error, we will compute best_transform and best_sets as some basic transformation.","category":"page"},{"location":"docs_oavi_transformation/","page":"Transforming data using textttOAVI","title":"Transforming data using textttOAVI","text":"# best transform and best sets\nbest_transform, best_sets = fit_oavi(X_train; psi=0.001)\n\n# apply transformation to test set\nX_test_transformed, sets_test = apply_G_transformation(best_sets, X_test)","category":"page"},{"location":"docs_oavi_transformation/","page":"Transforming data using textttOAVI","title":"Transforming data using textttOAVI","text":"Note that X_test has to have the same second dimension as X_train, that is size(X_train, 2) == size(X_test, 2), so be careful when applying the transformation to other data.","category":"page"},{"location":"docs_oavi_transformation/","page":"Transforming data using textttOAVI","title":"Transforming data using textttOAVI","text":"Lastly, to be safe, we check that the dimensions of the transformations indeed match the number of vanishing polynomials constructed by the algorithm.","category":"page"},{"location":"docs_oavi_transformation/","page":"Transforming data using textttOAVI","title":"Transforming data using textttOAVI","text":"println(\"Number of vanishing polynomials: \", size(best_sets.leading_terms, 2))\nsize(best_transform, 2) == size(X_test_transformed, 2) == size(best_sets.leading_terms, 2)","category":"page"},{"location":"docs_oavi_transformation/","page":"Transforming data using textttOAVI","title":"Transforming data using textttOAVI","text":"","category":"page"},{"location":"docs_oavi_transformation/","page":"Transforming data using textttOAVI","title":"Transforming data using textttOAVI","text":"This page was generated using Literate.jl.","category":"page"},{"location":"reference/1_algorithms/#Algorithms","page":"Algorithms","title":"Algorithms","text":"","category":"section"},{"location":"reference/1_algorithms/","page":"Algorithms","title":"Algorithms","text":"This section contains the main algorithms of the package.","category":"page"},{"location":"reference/1_algorithms/#OAVI","page":"Algorithms","title":"OAVI","text":"","category":"section"},{"location":"reference/1_algorithms/","page":"Algorithms","title":"Algorithms","text":"Modules = [AVI]\nPages = [\"oracle_avi.jl\"]","category":"page"},{"location":"reference/1_algorithms/#AVI.evaluate_oavi-Tuple{Any, Matrix{Float64}}","page":"Algorithms","title":"AVI.evaluate_oavi","text":"Applies the OAVI feature transformation to X_test. \n\n\n\n\n\n","category":"method"},{"location":"reference/1_algorithms/#AVI.fit_oavi-Tuple{Matrix{Float64}}","page":"Algorithms","title":"AVI.fit_oavi","text":"Creates OAVI feature transformation fitted to X_train\n\nArguments\n\n'X_train::Union{Matrix{Float64}, Vector{Vector{Float64}}}': training data\n'max_degree::Int64': max degree of polynomials computed (default 10)\n'psi::Float64': vanishing extent (default 0.1)\n'epsilon::Float64': accuracy for convex optimizer (default 1.0e-7)\n'tau::Union{Float64, Int64}': upper bound on norm of coefficient vector\n'lambda::Float64': regularization parameter\n'oracle::Union{String, <:Function}': string denoting which predefined constructor to use OR constructor function.                                       (external constructor function MUST have 'data' and 'labels' as varargs)\n'oracle_kwargs::Vector': Array containing keyword arguments for external constructor functions\n\nReturns\n\n'Xtraintransformed::Vector{Vector{Float64}}': transformed X_train\n'sets::SetsOandG': instance of 'SetsOandG' keeping track of important sets \n\n\n\n\n\n","category":"method"},{"location":"reference/1_algorithms/#VCA","page":"Algorithms","title":"VCA","text":"","category":"section"},{"location":"reference/1_algorithms/","page":"Algorithms","title":"Algorithms","text":"fit_oavi","category":"page"},{"location":"reference/1_algorithms/#AVI.fit_oavi","page":"Algorithms","title":"AVI.fit_oavi","text":"Creates OAVI feature transformation fitted to X_train\n\nArguments\n\n'X_train::Union{Matrix{Float64}, Vector{Vector{Float64}}}': training data\n'max_degree::Int64': max degree of polynomials computed (default 10)\n'psi::Float64': vanishing extent (default 0.1)\n'epsilon::Float64': accuracy for convex optimizer (default 1.0e-7)\n'tau::Union{Float64, Int64}': upper bound on norm of coefficient vector\n'lambda::Float64': regularization parameter\n'oracle::Union{String, <:Function}': string denoting which predefined constructor to use OR constructor function.                                       (external constructor function MUST have 'data' and 'labels' as varargs)\n'oracle_kwargs::Vector': Array containing keyword arguments for external constructor functions\n\nReturns\n\n'Xtraintransformed::Vector{Vector{Float64}}': transformed X_train\n'sets::SetsOandG': instance of 'SetsOandG' keeping track of important sets \n\n\n\n\n\n","category":"function"},{"location":"reference/1_algorithms/","page":"Algorithms","title":"Algorithms","text":"AVI.find_range_null_vca","category":"page"},{"location":"reference/1_algorithms/#AVI.find_range_null_vca","page":"Algorithms","title":"AVI.find_range_null_vca","text":"Performs FindRangeNull (using SVD) for VCA.  Reference: https://proceedings.mlr.press/v28/livni13.html\n\nArguments\n\n'F::Union{Matrix{Float64}, Matrix{Int64}}': TBD\n'C::Union{Matrix{Float64}, Matrix{Int64}}': TBD\n'psi::Float64': vanishing parameter\n\nReturns\n\n'Vcoefficientvectors::Union{Matrix{Float64}, Matrix{Int64}}': Coefficient vectors of polynomials we append to V.\n'Vevaluationvectors::Union{Matrix{Float64}, Matrix{Int64}}': Evaluation vectors of polynomials we append to V.\n'Fcoefficientvectors::Union{Matrix{Float64}, Matrix{Int64}}': Coefficient vectors of polynomials we append to F.\n'Fevaluationvectors::Union{Matrix{Float64}, Matrix{Int64}}': Evaluation vectors of polynomials we append to F.\n\n\n\n\n\n","category":"function"},{"location":"reference/1_algorithms/","page":"Algorithms","title":"Algorithms","text":"AVI.evaluate_vca","category":"page"},{"location":"reference/1_algorithms/#AVI.evaluate_vca","page":"Algorithms","title":"AVI.evaluate_vca","text":"Evaluates transformation corresponding to the polynomials in V.\n\n\n\n\n\n","category":"function"},{"location":"reference/1_algorithms/#Index","page":"Algorithms","title":"Index","text":"","category":"section"},{"location":"reference/1_algorithms/","page":"Algorithms","title":"Algorithms","text":"Pages = [\"1_algorithms.md\"]","category":"page"},{"location":"reference/5_auxiliary_funcs/#Auxiliary-functions","page":"Auxiliary functions","title":"Auxiliary functions","text":"","category":"section"},{"location":"reference/5_auxiliary_funcs/","page":"Auxiliary functions","title":"Auxiliary functions","text":"This section contains information about auxiliary functions used throughout the algorithm.","category":"page"},{"location":"reference/5_auxiliary_funcs/#AVI-specific-functions","page":"Auxiliary functions","title":"AVI specific functions","text":"","category":"section"},{"location":"reference/5_auxiliary_funcs/","page":"Auxiliary functions","title":"Auxiliary functions","text":"These functions are used primarily to aid in the computation of the approximate vanishing ideal.","category":"page"},{"location":"reference/5_auxiliary_funcs/","page":"Auxiliary functions","title":"Auxiliary functions","text":"Modules = [AVI]\nPages = [\"auxiliary_functions_avi.jl\"]","category":"page"},{"location":"reference/5_auxiliary_funcs/#AVI.l1_projection-Tuple{Any}","page":"Auxiliary functions","title":"AVI.l1_projection","text":"Projects x onto the L1 Ball with radius 'radius'.\n\nReference:  \"Efficient Projections onto the ℓ1-Ball for Learning in High Dimensions\", https://stanford.edu/~jduchi/projects/DuchiShSiCh08.pdf\n\n\n\n\n\n","category":"method"},{"location":"reference/5_auxiliary_funcs/#AVI.streaming_matrix_updates-NTuple{5, Any}","page":"Auxiliary functions","title":"AVI.streaming_matrix_updates","text":"Given A, A.T.A and (A.T.A)^-1 efficiently compute B = [A, a], B.T.B and (B.T.B)^-1. Necessary for fast inverse hessian boosting.\n\n\n\n\n\n","category":"method"},{"location":"reference/5_auxiliary_funcs/#AVI.update_coefficient_vectors-Tuple{Any, Any}","page":"Auxiliary functions","title":"AVI.update_coefficient_vectors","text":"Appends polynomial with coefficient vector based on coefficientvector and term to Gcoefficient_vectors.\n\n\n\n\n\n","category":"method"},{"location":"reference/5_auxiliary_funcs/#Other-auxiliary-functions","page":"Auxiliary functions","title":"Other auxiliary functions","text":"","category":"section"},{"location":"reference/5_auxiliary_funcs/","page":"Auxiliary functions","title":"Auxiliary functions","text":"Modules = [AVI]\nPages = [\"auxiliary_functions.jl\"]","category":"page"},{"location":"reference/5_auxiliary_funcs/#AVI.compute_degree-Tuple{Matrix{Int64}}","page":"Auxiliary functions","title":"AVI.compute_degree","text":"Computes sum (degree) of columns (terms) in A and returns output as (1 x size(A, 2)) matrix.\n\n\n\n\n\n","category":"method"},{"location":"reference/5_auxiliary_funcs/#AVI.deg_lex_sort","page":"Auxiliary functions","title":"AVI.deg_lex_sort","text":"sorts matrix1 degree-lexicographically and matrix2 accordingly\n\n\n\n\n\n","category":"function"},{"location":"reference/5_auxiliary_funcs/#AVI.find_first_non_zero_entries-Tuple{Matrix{T} where T}","page":"Auxiliary functions","title":"AVI.find_first_non_zero_entries","text":"Finds first non-zero entry in each column and returns a list of the indices. In case of a zero-column returns first index.\n\n\n\n\n\n","category":"method"},{"location":"reference/5_auxiliary_funcs/#AVI.find_last_non_zero_entries-Tuple{Matrix{T} where T}","page":"Auxiliary functions","title":"AVI.find_last_non_zero_entries","text":"Finds last non-zero entry in each column and returns a list of the indices. In case of a zero-column returns last index.\n\n\n\n\n\n","category":"method"},{"location":"reference/5_auxiliary_funcs/#AVI.get_unique_columns","page":"Auxiliary functions","title":"AVI.get_unique_columns","text":"finds unique columns in matrix x1 and returns only unique elements in x1 as well as corresponding columns in x2.\n\n\n\n\n\n","category":"function"},{"location":"reference/5_auxiliary_funcs/#AVI.orthogonal_projection-Tuple{Matrix{Float64}, Vector{Float64}}","page":"Auxiliary functions","title":"AVI.orthogonal_projection","text":"Obtains orthogonal projections of vector projected onto vectors.\n\n\n\n\n\n","category":"method"},{"location":"reference/5_auxiliary_funcs/#Printing-polynomials","page":"Auxiliary functions","title":"Printing polynomials","text":"","category":"section"},{"location":"reference/5_auxiliary_funcs/","page":"Auxiliary functions","title":"Auxiliary functions","text":"Modules = [AVI]\nPages = [\"print_polynomials.jl\"]","category":"page"},{"location":"reference/5_auxiliary_funcs/#AVI.convert_term_to_latex-Tuple{Vector{Int64}}","page":"Auxiliary functions","title":"AVI.convert_term_to_latex","text":"Converts a term given as a vector denoting the exponents into LaTeX string\n\n\n\n\n\n","category":"method"},{"location":"reference/5_auxiliary_funcs/#AVI.print_polynomials-Tuple{Any}","page":"Auxiliary functions","title":"AVI.print_polynomials","text":"Prints the polynomials obtained through OAVI as a LaTeX string.\n\n'digits' can be used to determine how many decimal places you want to round to.  Terms with rounded coefficient values 0.0 are omitted and coefficients with value 1.0 are omitted.\n\n\n\n\n\n","category":"method"},{"location":"reference/5_auxiliary_funcs/#Index","page":"Auxiliary functions","title":"Index","text":"","category":"section"},{"location":"reference/5_auxiliary_funcs/","page":"Auxiliary functions","title":"Auxiliary functions","text":"Pages = [\"5_auxiliary_funcs.md\"]","category":"page"},{"location":"reference/0_reference/#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"reference/0_reference/","page":"API Reference","title":"API Reference","text":"The pages in this section reference the documentation for specific functions.","category":"page"},{"location":"docs_vca_transformation/#Transforming-data-using-\\texttt{VCA}","page":"Transforming data using textttVCA","title":"Transforming data using textttVCA","text":"","category":"section"},{"location":"docs_vca_transformation/","page":"Transforming data using textttVCA","title":"Transforming data using textttVCA","text":"If you whis to use textttVCA instead of textttOAVI to obtain your transformation, then here we will briefly explain how you can go about it.","category":"page"},{"location":"docs_vca_transformation/#Choosing-the-right-transformation","page":"Transforming data using textttVCA","title":"Choosing the right transformation","text":"","category":"section"},{"location":"docs_vca_transformation/","page":"Transforming data using textttVCA","title":"Transforming data using textttVCA","text":"Unlike textttOAVI, textttVCA does not enjoy a known relation between the vanishing parameter psi and the degree of constructed polynomials. This makes a wider range of psi's to compare necessary, even if one has some knowledge about which polynomial degrees may prove better. Luckily, the way to go about finding the best transformation is very similar to the one presented for textttOAVI.","category":"page"},{"location":"docs_vca_transformation/","page":"Transforming data using textttVCA","title":"Transforming data using textttVCA","text":"Once again, let's begin by creating or reading in our data set.","category":"page"},{"location":"docs_vca_transformation/","page":"Transforming data using textttVCA","title":"Transforming data using textttVCA","text":"using AVI\nusing DataFrames\nusing CSV\nusing Random\n\n# create data\nX = rand(100, 3)\n\n# put it into a DataFrame\ndf = DataFrame(X, :auto)\n\n# write it to 'example.csv' in 'examples' folder\nCSV.write(\"examples/example_vca.csv\", df);\n\n# read the data\nread_df = CSV.read(\"examples/example_vca.csv\", DataFrame, types=Float64)\n\n# convert DataFrame to Matrix\ndata = Matrix(read_df)","category":"page"},{"location":"docs_vca_transformation/","page":"Transforming data using textttVCA","title":"Transforming data using textttVCA","text":"Just as with textttOAVI, fit_vca expects the data matrix to be of type Float64.","category":"page"},{"location":"docs_vca_transformation/","page":"Transforming data using textttVCA","title":"Transforming data using textttVCA","text":"As with the previous example, the next step is to choose some range of psi's you wish to test. We recommend to choose a wider range, for example psis=[0.1, 0.05, 0.01, 0.005, 0.001, 0.0005, 0.0001]. Now, just as with textttOAVI, we wish to test and compare the transformations for different values of psi.","category":"page"},{"location":"docs_vca_transformation/","page":"Transforming data using textttVCA","title":"Transforming data using textttVCA","text":"# split train and test data\nX_train, X_test = data[1:90, :], data[91:end, :]\n\n# define psis\npsis=[0.1, 0.05, 0.01, 0.005, 0.001, 0.0005, 0.0001]\n\n# init best transform and best sets\nbest_transform_vca, best_sets_vca = nothing, nothing\n\n# init error\nerror = Inf64\n\n# loop psis\nfor psi in psis\n    # transformation with current psi\n    X_train_transformed_vca, sets_train_vca = fit_vca(X_train; psi=psi)\n\n    \"\"\"\n    if X_train_transformed_vca !== nothing\n        new_error = classifier(X_train_transformed_vca, class_labels)\n        if new_error < error\n            error = new_error\n            best_transform_vca, best_sets_vca = X_train_transformed_vca, sets_train_vca\n        end\n    end\n    \"\"\"\nend","category":"page"},{"location":"docs_vca_transformation/","page":"Transforming data using textttVCA","title":"Transforming data using textttVCA","text":"Use your favorite classification method to compare the transformations and choose the one that fits your data and problem best.","category":"page"},{"location":"docs_vca_transformation/#Applying-the-transformation","page":"Transforming data using textttVCA","title":"Applying the transformation","text":"","category":"section"},{"location":"docs_vca_transformation/","page":"Transforming data using textttVCA","title":"Transforming data using textttVCA","text":"After having found the transformation best suited to your data, you can apply this transformation to the data you wish to classify. Passing best_sets_vca and X_test to apply_V_transformation applies the textttVCA transformation stored in best_sets_vca to X_test. We compute some best_transform_vca and 'bestsetsvca' as to not get an error.","category":"page"},{"location":"docs_vca_transformation/","page":"Transforming data using textttVCA","title":"Transforming data using textttVCA","text":"# best transform and best sets for VCA\nbest_transform_vca, best_sets_vca = fit_vca(X_train; psi=0.001)\n\n# apply VCA transformation to test set\nX_test_transformed_vca, sets_test_vca = apply_V_transformation(best_sets_vca, X_test)","category":"page"},{"location":"docs_vca_transformation/","page":"Transforming data using textttVCA","title":"Transforming data using textttVCA","text":"Once again, the data to which the transformation is applied should have the same second dimension as X_train, which means size(X_train, 2) == size(X_test, 2) should hold.","category":"page"},{"location":"docs_vca_transformation/","page":"Transforming data using textttVCA","title":"Transforming data using textttVCA","text":"We perform the same sanity check as for textttOAVI to see if the dimension of the transformation matches.","category":"page"},{"location":"docs_vca_transformation/","page":"Transforming data using textttVCA","title":"Transforming data using textttVCA","text":"# get all polynomials into single matrix\npolys = AVI.V_to_matrix(best_sets_vca)\n\nprintln(\"Number of vanishing polynomials: \", size(polys, 2))\nsize(best_transform_vca, 2) == size(X_test_transformed_vca, 2) == size(polys, 2)","category":"page"},{"location":"docs_vca_transformation/","page":"Transforming data using textttVCA","title":"Transforming data using textttVCA","text":"","category":"page"},{"location":"docs_vca_transformation/","page":"Transforming data using textttVCA","title":"Transforming data using textttVCA","text":"This page was generated using Literate.jl.","category":"page"},{"location":"reference/4_terms_and_polys/#Terms-and-polynomials","page":"Terms and polynomials","title":"Terms and polynomials","text":"","category":"section"},{"location":"reference/4_terms_and_polys/","page":"Terms and polynomials","title":"Terms and polynomials","text":"This section contains information about the handling of terms and polynomials constructed and used during OAVI and VCA. Many of the functions work relatively similar, simply adjusted to the respective structure of storing the information.","category":"page"},{"location":"reference/4_terms_and_polys/#Sets-\\mathcal{O}-and-\\mathcal{G}","page":"Terms and polynomials","title":"Sets mathcalO and mathcalG","text":"","category":"section"},{"location":"reference/4_terms_and_polys/","page":"Terms and polynomials","title":"Terms and polynomials","text":"Modules = [AVI]\nPages = [\"terms_and_polynomials.jl\"]","category":"page"},{"location":"reference/4_terms_and_polys/#AVI.SetsOandG","page":"Terms and polynomials","title":"AVI.SetsOandG","text":"Creates and keeps track of sets O and G for OAVI.\n\n\n\n\n\n","category":"type"},{"location":"reference/4_terms_and_polys/#AVI.apply_G_transformation-Tuple{AVI.SetsOandG, Any}","page":"Terms and polynomials","title":"AVI.apply_G_transformation","text":"applies the transformation corresponding to G to X_test\n\n\n\n\n\n","category":"method"},{"location":"reference/4_terms_and_polys/#AVI.construct_SetsOandG-Tuple{Any}","page":"Terms and polynomials","title":"AVI.construct_SetsOandG","text":"initializes SetsOandG instance w.r.t. X_train\n\n\n\n\n\n","category":"method"},{"location":"reference/4_terms_and_polys/#AVI.evaluate_transformation-Tuple{AVI.SetsOandG}","page":"Terms and polynomials","title":"AVI.evaluate_transformation","text":"Evaluates the transformation corresponding to the polynomials in Gcoefficientvectors.\n\nArguments\n\n'sets::SetsOandG': instance of SetsOandG, containing information on transformation\n\nReturns\n\n'totalnumberofzeros::Int64': Sum of all zero entries in coefficientvectors in Gcoefficientvectors.\n'totalnumberofentries::Int64': Total number of entries in coefficientvectors in Gcoefficientvectors.\n'avgsparsity::Float64': The average sparsity of coefficientvectors in Gcoefficientvectors.\n'numberofpolynomials::Int64': Number of polynomials in G.\n'numberofterms::Int64': Number of terms in O.\n'degree::Float64': Average degree of polynomials in G.\n\n\n\n\n\n","category":"method"},{"location":"reference/4_terms_and_polys/#AVI.update_G","page":"Terms and polynomials","title":"AVI.update_G","text":"updates G sets\n\n\n\n\n\n","category":"function"},{"location":"reference/4_terms_and_polys/#AVI.update_O-NTuple{4, Any}","page":"Terms and polynomials","title":"AVI.update_O","text":"updates O sets\n\n\n\n\n\n","category":"method"},{"location":"reference/4_terms_and_polys/#AVI.update_border-NTuple{4, Any}","page":"Terms and polynomials","title":"AVI.update_border","text":"updates border sets\n\n\n\n\n\n","category":"method"},{"location":"reference/4_terms_and_polys/#AVI.update_leading_terms","page":"Terms and polynomials","title":"AVI.update_leading_terms","text":"updates leading terms\n\n\n\n\n\n","category":"function"},{"location":"reference/4_terms_and_polys/#AVI.update_permutations-Tuple{Any, Any}","page":"Terms and polynomials","title":"AVI.update_permutations","text":"updates permutations\n\n\n\n\n\n","category":"method"},{"location":"reference/4_terms_and_polys/#Sets-\\mathcal{F}-and-\\mathcal{V}","page":"Terms and polynomials","title":"Sets mathcalF and mathcalV","text":"","category":"section"},{"location":"reference/4_terms_and_polys/","page":"Terms and polynomials","title":"Terms and polynomials","text":"Modules = [AVI]\nPages = [\"terms_and_polynomials_vca.jl\"]","category":"page"},{"location":"reference/4_terms_and_polys/#AVI.SetsVCA","page":"Terms and polynomials","title":"AVI.SetsVCA","text":"Manages the sets V, C and F for VCA.\n\n\n\n\n\n","category":"type"},{"location":"reference/4_terms_and_polys/#AVI.F_to_matrix-Tuple{AVI.SetsVCA}","page":"Terms and polynomials","title":"AVI.F_to_matrix","text":"Transforms SetsVCA.Fs into single matrix.\n\n\n\n\n\n","category":"method"},{"location":"reference/4_terms_and_polys/#AVI.V_to_matrix-Tuple{AVI.SetsVCA}","page":"Terms and polynomials","title":"AVI.V_to_matrix","text":"Transforms SetsVCA.Vs into single matrix.\n\n\n\n\n\n","category":"method"},{"location":"reference/4_terms_and_polys/#AVI.apply_V_transformation-Tuple{AVI.SetsVCA, Matrix{Float64}}","page":"Terms and polynomials","title":"AVI.apply_V_transformation","text":"Applies transformation corresponding to V polynomials to X_test.\n\n\n\n\n\n","category":"method"},{"location":"reference/4_terms_and_polys/#AVI.construct_SetsVCA-Tuple{Union{Matrix{Float64}, Matrix{Int64}}}","page":"Terms and polynomials","title":"AVI.construct_SetsVCA","text":"Given the data X, this function constructs the intial state of 'SetsVCA'.\n\n\n\n\n\n","category":"method"},{"location":"reference/4_terms_and_polys/#AVI.construct_border_vca-Tuple{AVI.SetsVCA}","page":"Terms and polynomials","title":"AVI.construct_border_vca","text":"constructs the border for current state of the algorithm.\n\n\n\n\n\n","category":"method"},{"location":"reference/4_terms_and_polys/#AVI.evaluate_transformation-Tuple{AVI.SetsVCA}","page":"Terms and polynomials","title":"AVI.evaluate_transformation","text":"Evaluates the transformation corresponding to the polynomials in V w.r.t. the functions in F and C\n\nArguments\n\n'sets::SetsVCA': instance of SetsVCA.\n\nReturns\n\n'totalnumberofzeros::Int64': Sum of all zero entries in coefficientvectors in Vcoefficientvectors.\n'totalnumberofentries::Int64': Total number of entries in coefficientvectors in Vcoefficientvectors.\n'avgsparsity::Float64': The average sparsity of coefficientvectors in Vcoefficientvectors.\n'numberofpolynomials::Int64': Number of polynomials in Vcoefficientvectors.\n'numberofterms::Int64': Number of non-vanishing terms.\n'degree::Float64': Average degree of polynomials in V.\n\n\n\n\n\n","category":"method"},{"location":"reference/4_terms_and_polys/#AVI.update_C-Tuple{AVI.SetsVCA, Matrix{Float64}}","page":"Terms and polynomials","title":"AVI.update_C","text":"updates C\n\n\n\n\n\n","category":"method"},{"location":"reference/4_terms_and_polys/#AVI.update_F-Tuple{AVI.SetsVCA, Union{Matrix{Float64}, Matrix{Int64}}, Matrix{Float64}}","page":"Terms and polynomials","title":"AVI.update_F","text":"updates F sets\n\n\n\n\n\n","category":"method"},{"location":"reference/4_terms_and_polys/#AVI.update_V-Tuple{AVI.SetsVCA, Matrix{Float64}, Matrix{Float64}}","page":"Terms and polynomials","title":"AVI.update_V","text":"updates V sets.\n\n\n\n\n\n","category":"method"},{"location":"reference/4_terms_and_polys/#Index","page":"Terms and polynomials","title":"Index","text":"","category":"section"},{"location":"reference/4_terms_and_polys/","page":"Terms and polynomials","title":"Terms and polynomials","text":"Pages = [\"4_terms_and_polys.md\"]","category":"page"},{"location":"print_polynomials/#Printing-polynomials","page":"Printing polynomials","title":"Printing polynomials","text":"","category":"section"},{"location":"print_polynomials/","page":"Printing polynomials","title":"Printing polynomials","text":"Apart from just obtaining an textttOAVI transformation for some data, you might also want to take a look at the polynomials themselves. To do that we provide the function print_polynomials which takes as input a SetsOandG instance sets. The function then puts the polynomials into LaTeX format and prints them, line by line, to the command line.","category":"page"},{"location":"print_polynomials/","page":"Printing polynomials","title":"Printing polynomials","text":"# some data\nX = rand(100, 3)\n_, sets = fit_oavi(X; psi=0.005)\n\n# print polynomials\nprint_polynomials(sets)","category":"page"},{"location":"print_polynomials/","page":"Printing polynomials","title":"Printing polynomials","text":"As an example, the output may look something like this: ","category":"page"},{"location":"print_polynomials/","page":"Printing polynomials","title":"Printing polynomials","text":"x_{3}^{2} - 0.1x_2x_3 + 0.09x_1x_3 + 0.07x_{2}^{2} - 0.05x_1x_2 + 0.04x_{1}^{2} - 1.03x_3 - 0.01x_2 - 0.04x_1 + 0.18\nx_{1}^{3} + 0.01x_2x_3 - 0.03x_1x_3 - 0.01x_1x_2 - 1.48x_{1}^{2} + 0.01x_3 + 0.6x_1 - 0.06\nx_{1}^{2}x_2 + 0.01x_2x_3 - 0.02x_1x_3 - 0.05x_{2}^{2} - 1.02x_1x_2 - 0.44x_{1}^{2} + 0.01x_3 + 0.22x_2 + 0.46x_1 - 0.09\nx_1x_{2}^{2} - 0.03x_2x_3 + 0.08x_1x_3 - 0.52x_{2}^{2} - 1.0x_1x_2 - 0.01x_{1}^{2} - 0.02x_3 + 0.51x_2 + 0.13x_1 - 0.07\nx_{2}^{3} + 0.07x_2x_3 + 0.03x_1x_3 - 1.41x_{2}^{2} - 0.04x_1x_2 - 0.06x_{1}^{2} - 0.04x_3 + 0.49x_2 + 0.04x_1 - 0.02\nx_{1}^{2}x_3 - 0.96x_1x_3 + 0.02x_{2}^{2} - 0.03x_1x_2 - 0.54x_{1}^{2} + 0.15x_3 - 0.01x_2 + 0.53x_1 - 0.09\nx_1x_2x_3 - 0.51x_2x_3 - 0.42x_1x_3 - 0.01x_{2}^{2} - 0.44x_1x_2 - 0.01x_{1}^{2} + 0.2x_3 + 0.24x_2 + 0.2x_1 - 0.1\nx_{2}^{2}x_3 - 0.94x_2x_3 - 0.04x_1x_3 - 0.44x_{2}^{2} - 0.03x_1x_2 + 0.02x_{1}^{2} + 0.16x_3 + 0.44x_2 + 0.01x_1 - 0.08\nx_1x_{3}^{2} - 0.09x_2x_3 - 0.97x_1x_3 + 0.02x_{2}^{2} + 0.06x_{1}^{2} + 0.02x_3 + 0.01x_2 + 0.11x_1\nx_2x_{3}^{2} - 1.04x_2x_3 + 0.02x_{2}^{2} + 0.06x_{1}^{2} - 0.01x_3 + 0.18x_2 - 0.05x_1 + 0.01","category":"page"},{"location":"print_polynomials/","page":"Printing polynomials","title":"Printing polynomials","text":"Then, it is as easy as copy and pasting it into LaTeX with your preferred formatting and you can take a look at them.","category":"page"},{"location":"print_polynomials/","page":"Printing polynomials","title":"Printing polynomials","text":"x_3^2 - 01x_2x_3 + 009x_1x_3 + 007x_2^2 - 005x_1x_2 + 004x_1^2 - 103x_3 - 001x_2 - 004x_1 + 018","category":"page"},{"location":"print_polynomials/","page":"Printing polynomials","title":"Printing polynomials","text":"x_1^3 + 001x_2x_3 - 003x_1x_3 - 001x_1x_2 - 148x_1^2 + 001x_3 + 06x_1 - 006","category":"page"},{"location":"print_polynomials/","page":"Printing polynomials","title":"Printing polynomials","text":"x_1^2x_2 + 001x_2x_3 - 002x_1x_3 - 005x_2^2 - 102x_1x_2 - 044x_1^2 + 001x_3 + 022x_2 + 046x_1 - 009","category":"page"},{"location":"print_polynomials/","page":"Printing polynomials","title":"Printing polynomials","text":"x_1x_2^2 - 003x_2x_3 + 008x_1x_3 - 052x_2^2 - 10x_1x_2 - 001x_1^2 - 002x_3 + 051x_2 + 013x_1 - 007","category":"page"},{"location":"print_polynomials/","page":"Printing polynomials","title":"Printing polynomials","text":"x_2^3 + 007x_2x_3 + 003x_1x_3 - 141x_2^2 - 004x_1x_2 - 006x_1^2 - 004x_3 + 049x_2 + 004x_1 - 002","category":"page"},{"location":"print_polynomials/","page":"Printing polynomials","title":"Printing polynomials","text":"x_1^2x_3 - 096x_1x_3 + 002x_2^2 - 003x_1x_2 - 054x_1^2 + 015x_3 - 001x_2 + 053x_1 - 009","category":"page"},{"location":"print_polynomials/","page":"Printing polynomials","title":"Printing polynomials","text":"x_1x_2x_3 - 051x_2x_3 - 042x_1x_3 - 001x_2^2 - 044x_1x_2 - 001x_1^2 + 02x_3 + 024x_2 + 02x_1 - 01","category":"page"},{"location":"print_polynomials/","page":"Printing polynomials","title":"Printing polynomials","text":"x_2^2x_3 - 094x_2x_3 - 004x_1x_3 - 044x_2^2 - 003x_1x_2 + 002x_1^2 + 016x_3 + 044x_2 + 001x_1 - 008","category":"page"},{"location":"print_polynomials/","page":"Printing polynomials","title":"Printing polynomials","text":"x_1x_3^2 - 009x_2x_3 - 097x_1x_3 + 002x_2^2 + 006x_1^2 + 002x_3 + 001x_2 + 011x_1","category":"page"},{"location":"print_polynomials/","page":"Printing polynomials","title":"Printing polynomials","text":"x_2x_3^2 - 104x_2x_3 + 002x_2^2 + 006x_1^2 - 001x_3 + 018x_2 - 005x_1 + 001","category":"page"},{"location":"print_polynomials/","page":"Printing polynomials","title":"Printing polynomials","text":"The function print_polynomials has an additional keyword argument digits with which you can decide up to how many digits the coefficients should be rounded, e.g. print_polynomials(sets; digits=4) to round to 4 decimal places. There is a choice you have to make here as some coefficients may be smaller than the decimal place you are rounding to but can nonetheless influence the evaluation of the polynomial in a meaningful way. Be aware of that when printing the polynomials and do not fall under the impression that these are the exact polynomials found during textttOAVI. We completely omit terms that have a rounded coefficient of 00, as well as omitting coefficients that have a rounded value of 10. This is done to declutter the printed polynomials, but, as mentioned above, has the side effect that some terms contained in the polynomial may not be printed due to the coefficients being too small.","category":"page"},{"location":"docs_custom_oracle/","page":"Custom Oracles","title":"Custom Oracles","text":"EditURL = \"../../examples/docs_custom_oracle.jl\"","category":"page"},{"location":"docs_custom_oracle/#Custom-Oracles","page":"Custom Oracles","title":"Custom Oracles","text":"","category":"section"},{"location":"docs_custom_oracle/","page":"Custom Oracles","title":"Custom Oracles","text":"In this section we will present an example of how to construct your own oracle to run in textttOAVI. We will be showing this for the objective function frac1mAx + b_2^2 and a Frank-Wolfe oracle. It is easily extendable to other setups.","category":"page"},{"location":"docs_custom_oracle/#Preparing-data","page":"Custom Oracles","title":"Preparing data","text":"","category":"section"},{"location":"docs_custom_oracle/","page":"Custom Oracles","title":"Custom Oracles","text":"Since custom oracles may vary in the data needed for the computations, we only require a custom oracle to need data and labels to construct everything, i.e. the data matrix A and the label vector b. The first step is to prepare the data you need for your objective function. For our example, we extend our function to better see which combinations of the inputs we need.","category":"page"},{"location":"docs_custom_oracle/","page":"Custom Oracles","title":"Custom Oracles","text":"frac1mAx+b_2^2 = frac1m langle Ax+b Ax+brangle = frac1m (langle Ax Axrangle + 2langle Ax brangle + langle b brangle)","category":"page"},{"location":"docs_custom_oracle/","page":"Custom Oracles","title":"Custom Oracles","text":"Writing this in the form of matrix-vector multiplication, we get","category":"page"},{"location":"docs_custom_oracle/","page":"Custom Oracles","title":"Custom Oracles","text":"frac1m (langle Ax Axrangle + 2langle Ax brangle + langle b brangle) = frac1m(x^top A^top A x + 2x^top A^top b + b^top b)","category":"page"},{"location":"docs_custom_oracle/","page":"Custom Oracles","title":"Custom Oracles","text":"Let's write a function that computes all the necessary parts. Inlcuding a frac2m factor instead of frac1m is just personal preference. We simply divide by 2 later.","category":"page"},{"location":"docs_custom_oracle/","page":"Custom Oracles","title":"Custom Oracles","text":"using AVI\nusing FrankWolfe\nusing LinearAlgebra\nusing Random\n\nfunction prepare_data(A, b)\n    m, _ = size(A)\n    # A.T A\n    A_squared = 2/m * (A' * A)\n\n    # A.T b\n    A_b = 2/m * (A' * b)\n\n    # b.T b\n    b_squared = 2/m * (b' * b)\n\n    return A_squared, A_b, b_squared\nend","category":"page"},{"location":"docs_custom_oracle/#Creating-the-objective-function","page":"Custom Oracles","title":"Creating the objective function","text":"","category":"section"},{"location":"docs_custom_oracle/","page":"Custom Oracles","title":"Custom Oracles","text":"The next step is to create the objective function (and in our case its gradient). For this we use the previously defined function to prepare the data and create the objective.","category":"page"},{"location":"docs_custom_oracle/","page":"Custom Oracles","title":"Custom Oracles","text":"function objective(data, labels)\n    # prepare data for objective\n    A_squared, A_b, b_squared = prepare_data(data, labels)\n\n    # define objective\n    function evaluate_objective(x)\n        return (1 / 2) * (x' * A_squared * x) + (x' * A_b) + (1 / 2) * b_squared\n    end\n\n    # define gradient\n    function evaluate_gradient!(storage, x)\n        # 'storage' is specific to structure in 'FrankWolfe.jl'\n        return storage .= A_squared * x + A_b\n    end\n\n    return evaluate_objective, evaluate_gradient!\nend","category":"page"},{"location":"docs_custom_oracle/#Defining-the-feasible-region","page":"Custom Oracles","title":"Defining the feasible region","text":"","category":"section"},{"location":"docs_custom_oracle/","page":"Custom Oracles","title":"Custom Oracles","text":"Since we are dealing with a constrained optimization problem, defining a feasible region is necessary. We will use FrankWolfe.jl's built-in feasible regions, however one may construct their own feasible region through other means, so for the sake of this presentation we will once again define a function. This function will define the ell_p-ball with a given radius.","category":"page"},{"location":"docs_custom_oracle/","page":"Custom Oracles","title":"Custom Oracles","text":"function feasible_region(p, radius)\n    return FrankWolfe.LpNormLMO{p}(radius)\nend","category":"page"},{"location":"docs_custom_oracle/","page":"Custom Oracles","title":"Custom Oracles","text":"Closely tied with the feasible region is the choice of a starting point for the oracle. For the LpNormLMO we can use compute_extreme_point to obtain a starting vertex of our feasible region by calling region = feasible_region(1, 1000) and after that x0 = compute_extreme_point(region, zeros(Float64, size(data, 2)))","category":"page"},{"location":"docs_custom_oracle/#Calling-the-Oracle","page":"Custom Oracles","title":"Calling the Oracle","text":"","category":"section"},{"location":"docs_custom_oracle/","page":"Custom Oracles","title":"Custom Oracles","text":"The final step for our custom oracle is calling the oracle with all the things we prepared. textttOAVI requires degree-lexicographical term ordering and assumes a leading term coefficient of 1. Hence, your oracle should find a coefficient vector x that only contains coefficients for data as the coefficient for labels is fixed at 1. With the coefficient vector obtained, we compute the loss and return both coefficient_vector and loss. As an example we take the blended_conditional_gradient algorithm as an oracle.","category":"page"},{"location":"docs_custom_oracle/","page":"Custom Oracles","title":"Custom Oracles","text":"function custom_oracle(data, labels; epsilon=1.0e-7, max_iteration=10000)\n    # get necessary data\n    f, grad! = objective(data, labels)\n    region = feasible_region(1, 1000.)\n    x0 = compute_extreme_point(region, zeros(Float64, size(data, 2)))\n\n    # obtain coefficient vector\n    coefficient_vector, _ = blended_conditional_gradient(\n                                                        f,\n                                                        grad!,\n                                                        region,\n                                                        x0;\n                                                        epsilon=epsilon,\n                                                        max_iteration=max_iteration\n                                                        )\n\n    # compute loss\n    loss = f(coefficient_vector)\n\n    # extend coefficient vector with leading term coefficient 1\n    coefficient_vector = vcat(coefficient_vector, [1])\n\n    return coefficient_vector, loss\nend","category":"page"},{"location":"docs_custom_oracle/#Putting-it-all-together","page":"Custom Oracles","title":"Putting it all together","text":"","category":"section"},{"location":"docs_custom_oracle/","page":"Custom Oracles","title":"Custom Oracles","text":"Now that you know what your custom oracle is expected to return and how one can go about defining such a constructor, it remains to give it to textttOAVI to use.","category":"page"},{"location":"docs_custom_oracle/","page":"Custom Oracles","title":"Custom Oracles","text":"# some data\nX = rand(10000, 10)\n\n# transformation obtained through OAVI by using your custom oracle\nX_transformed, sets = fit_oavi(X; oracle=custom_oracle)","category":"page"},{"location":"docs_custom_oracle/","page":"Custom Oracles","title":"Custom Oracles","text":"You can also pass further kwargs used by your oracle and we will pass them through to your oracle call. This is done by the oracle_kwargs argument. Let's say we want to pass the keyword arguments epsilon=1.0e-5 and max_iteration=5000 along to our custom oracle.","category":"page"},{"location":"docs_custom_oracle/","page":"Custom Oracles","title":"Custom Oracles","text":"kwargs = [(:epsilon, 1.0e-5), (:max_iteration, 5000)]\n\nX_transformed, sets = fit_oavi(X; oracle=custom_oracle, oracle_kwargs=kwargs)","category":"page"},{"location":"docs_custom_oracle/","page":"Custom Oracles","title":"Custom Oracles","text":"The above code will call custom_oracle with the keyword arguments epsilon and max_iteration exchanged for 1.0e-5 and 5000, respectively, that is, custom_oracle(data, labels; epsilon=1.0e-5, max_iteration=5000) and ultimately when calling the algorithm in our example blended_conditional_gradient(f, grad!, region, x0; epsilon=1.0e-5, max_iteration=5000).","category":"page"},{"location":"docs_custom_oracle/","page":"Custom Oracles","title":"Custom Oracles","text":"","category":"page"},{"location":"docs_custom_oracle/","page":"Custom Oracles","title":"Custom Oracles","text":"This page was generated using Literate.jl.","category":"page"},{"location":"#AVI.jl","page":"Home","title":"AVI.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: Dev)","category":"page"},{"location":"","page":"Home","title":"Home","text":"This package is a toolbox for polynomial feature extraction and transformation using the Oracle Approximate Vanishing Ideal Algorithm.","category":"page"},{"location":"#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The Oracle Approximate Vanishing Ideal (textttOAVI) algorithm was designed to compute the vanishing ideal of a set of points. Instead of adopting the then common approach of using singular value decomposition, textttOAVI finds vanishing polynomials by solving a convex optimization problem of the form","category":"page"},{"location":"","page":"Home","title":"Home","text":"min_x in C f(x)","category":"page"},{"location":"","page":"Home","title":"Home","text":"where f is a differentiable convex function and C is a compact and convex set. Usually f will be of the form","category":"page"},{"location":"","page":"Home","title":"Home","text":"f(x) = Ax + b_2^2","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The most recent release is available via:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pkg.add(url=\"https://github.com/ZIB-IOL/AVI.jl.git\")","category":"page"},{"location":"#Getting-started","page":"Home","title":"Getting started","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"We provide built-in oracles that construct the objective function and feasible region and solve the optimization problem with a version of the Frank-Wolfe (conditional gradients) algorithm implemented in FrankWolfe.jl. Obtaining a basic feature transformation for some random data textttX is as simple as:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using AVI\nusing random\n\nX = rand(10000, 5)\nX_transformed, sets = fit_oavi(X);","category":"page"},{"location":"","page":"Home","title":"Home","text":"X_transformed holds the transformed data and sets keeps track of important sets. It is recommended to adjust some keyword arguments for better results. See the examples section for more information.","category":"page"},{"location":"#Documentation-and-Examples","page":"Home","title":"Documentation and Examples","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To explore the contents of the package and see examples with a more detailed look at the different keyword arguments, go to the documentation.","category":"page"}]
}
